// en: Replay embedded capture assets and try to decode them.
// ja: 埋め込みキャプチャ資産を読み込み、デコードして表示するサンプル。
// en: Assets are embedded as C arrays via assets_embed.h (generated by the CLI).
// ja: アセットはCLIで生成された assets_embed.h 内の配列として埋め込まれている。

#include <ESP32IRPulseCodec.h>
#include "assets_embed.h"
#include <vector>
#include <string>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <cJSON.h>

// en: read embedded asset into RAM buffer (ESP32 stores in regular addressable memory)
// ja: 埋め込みアセットをRAMに読み込む（ESP32では通常メモリとして扱える）
static bool loadAssetToBuffer(size_t idx, std::vector<char> &out)
{
  if (idx >= assets_file_count)
    return false;
  size_t len = assets_file_sizes[idx];
  out.resize(len + 1);
  memcpy(out.data(), assets_file_data[idx], len);
  out[len] = '\0';
  return true;
}

// en: get string field from JSON (cJSON)
// ja: cJSON から文字列フィールドを取得
static std::string getStringField(cJSON *obj, const char *key)
{
  cJSON *item = cJSON_GetObjectItemCaseSensitive(obj, key);
  if (cJSON_IsString(item) && item->valuestring)
    return std::string(item->valuestring);
  return {};
}

// en: parse frameBytes array (decimal) if present
// ja: frameBytes 配列（10進）をパース
static std::vector<uint8_t> parseFrameBytes(cJSON *capture)
{
  std::vector<uint8_t> bytes;
  cJSON *arr = cJSON_GetObjectItemCaseSensitive(capture, "frameBytes");
  if (!cJSON_IsArray(arr))
    return bytes;
  cJSON *it = nullptr;
  cJSON_ArrayForEach(it, arr)
  {
    if (cJSON_IsNumber(it))
    {
      int v = it->valueint;
      if (v < 0)
        v = 0;
      if (v > 255)
        v = 255;
      bytes.push_back(static_cast<uint8_t>(v));
    }
  }
  return bytes;
}

// en: convert bytes to comma separated decimal string (for logging)
// ja: バイト列を10進のカンマ区切り文字列に変換（ログ出力用）
static std::string bytesToString(const std::vector<uint8_t> &bytes)
{
  std::string s;
  s.reserve(bytes.size() * 4);
  for (size_t i = 0; i < bytes.size(); ++i)
  {
    char buf[6];
    snprintf(buf, sizeof(buf), "%u", bytes[i]);
    if (i)
      s += ",";
    s += buf;
  }
  return s;
}

// en: build ITPSBuffer from JSON by cJSON traversal
// ja: cJSONでitps配列を辿ってITPSBufferを構築
static esp32ir::ITPSBuffer buildITPS(cJSON *capture)
{
  esp32ir::ITPSBuffer buf;
  // Try durationsUs first (µs list with sign). If present, build one frame using T_us from itps[0] or default 10.
  std::vector<int32_t> durationsUs;
  cJSON *durArr = cJSON_GetObjectItemCaseSensitive(capture, "durationsUs");
  if (cJSON_IsArray(durArr))
  {
    cJSON *dv = nullptr;
    cJSON_ArrayForEach(dv, durArr)
    {
      if (cJSON_IsNumber(dv))
        durationsUs.push_back(dv->valueint);
    }
  }

  cJSON *itpsArr = cJSON_GetObjectItemCaseSensitive(capture, "itps");
  auto quantizeSeq = [](const std::vector<int32_t> &usList, uint16_t T_us) {
    std::vector<int8_t> seq;
    for (int32_t us : usList)
    {
      bool mark = us > 0;
      int mag = us < 0 ? -us : us;
      int count = (mag + (T_us / 2)) / T_us; // round to nearest
      if (count < 1)
        count = 1;
      while (count > 127)
      {
        seq.push_back(static_cast<int8_t>((mark ? 1 : -1) * 127));
        count -= 127;
      }
      seq.push_back(static_cast<int8_t>((mark ? 1 : -1) * count));
    }
    return seq;
  };

  if (!durationsUs.empty())
  {
    uint16_t T_us = 10;
    if (cJSON_IsArray(itpsArr))
    {
      cJSON *first = cJSON_GetArrayItem(itpsArr, 0);
      cJSON *t = first ? cJSON_GetObjectItemCaseSensitive(first, "T_us") : nullptr;
      if (t && cJSON_IsNumber(t))
        T_us = static_cast<uint16_t>(t->valueint);
    }
    std::vector<int8_t> seq = quantizeSeq(durationsUs, T_us);
    esp32ir::ITPSFrame frame{T_us, static_cast<uint16_t>(seq.size()), seq.data(), 0};
    buf.addFrame(frame);
    return buf;
  }

  if (!cJSON_IsArray(itpsArr))
    return buf;

  cJSON *frameObj = nullptr;
  cJSON_ArrayForEach(frameObj, itpsArr)
  {
    if (!cJSON_IsObject(frameObj))
      continue;
    cJSON *t = cJSON_GetObjectItemCaseSensitive(frameObj, "T_us");
    uint16_t T_us = t && cJSON_IsNumber(t) ? static_cast<uint16_t>(t->valueint) : 10;
    cJSON *f = cJSON_GetObjectItemCaseSensitive(frameObj, "flags");
    uint8_t flags = f && cJSON_IsNumber(f) ? static_cast<uint8_t>(f->valueint) : 0;

    std::vector<int32_t> seqUs;
    cJSON *seqArr = cJSON_GetObjectItemCaseSensitive(frameObj, "seq");
    if (cJSON_IsArray(seqArr))
    {
      cJSON *sv = nullptr;
      cJSON_ArrayForEach(sv, seqArr)
      {
        if (cJSON_IsNumber(sv))
          seqUs.push_back(sv->valueint);
      }
    }
    std::vector<int8_t> seq = quantizeSeq(seqUs, T_us);
    esp32ir::ITPSFrame frame{T_us, static_cast<uint16_t>(seq.size()), seq.data(), flags};
    buf.addFrame(frame);
  }
  return buf;
}

void setup()
{
  Serial.begin(115200);
  delay(500);

  Serial.println(F("# assets replay start"));

  esp32ir::Receiver decoder;
  decoder.useRawPlusKnown(); // keep raw alongside decoded for tests

  size_t total = 0;
  size_t passed = 0;

  for (size_t i = 0; i < assets_file_count; ++i)
  {
    Serial.print(F("## file: "));
    Serial.println(assets_file_names[i]);

    std::vector<char> jsonBuf;
    if (!loadAssetToBuffer(i, jsonBuf))
    {
      Serial.println(F("load failed"));
      continue;
    }

    cJSON *root = cJSON_Parse(jsonBuf.data());
    if (!root)
    {
      Serial.println(F("parse error"));
      continue;
    }

    cJSON *capture = cJSON_GetObjectItemCaseSensitive(root, "capture");
    std::vector<uint8_t> frameBytes = capture ? parseFrameBytes(capture) : std::vector<uint8_t>{};
    esp32ir::ITPSBuffer buf = capture ? buildITPS(capture) : esp32ir::ITPSBuffer{};

    // en: configure decoder protocols (limit when protocol specified)
    // ja: 指定プロトコルがある場合はデコード対象を限定
    decoder.clearProtocols(); // en/ja: try all protocols; do not restrict by JSON proto

    esp32ir::RxResult result{};
    decoder.decode(buf, result, false);

    // decode payload based on result.protocol
    bool payloadDecoded = false;
    esp32ir::payload::NEC nec{};
    esp32ir::payload::SONY sony{};
    esp32ir::payload::AEHA aeha{};
    esp32ir::payload::Panasonic pana{};
    esp32ir::payload::JVC jvc{};
    esp32ir::payload::Samsung samsung{};
    esp32ir::payload::LG lg{};
    esp32ir::payload::Denon denon{};
    esp32ir::payload::RC5 rc5{};
    esp32ir::payload::RC6 rc6{};
    esp32ir::payload::Apple apple{};
    esp32ir::payload::Pioneer pioneer{};
    esp32ir::payload::Toshiba toshiba{};
    esp32ir::payload::Mitsubishi mitsu{};
    esp32ir::payload::Hitachi hitachi{};

    if (result.status == esp32ir::RxStatus::DECODED)
    {
      switch (result.protocol)
      {
      case esp32ir::Protocol::NEC:
        payloadDecoded = esp32ir::decodeNEC(result, nec);
        break;
      case esp32ir::Protocol::SONY:
        payloadDecoded = esp32ir::decodeSONY(result, sony);
        break;
      case esp32ir::Protocol::AEHA:
        payloadDecoded = esp32ir::decodeAEHA(result, aeha);
        break;
      case esp32ir::Protocol::Panasonic:
        payloadDecoded = esp32ir::decodePanasonic(result, pana);
        break;
      case esp32ir::Protocol::JVC:
        payloadDecoded = esp32ir::decodeJVC(result, jvc);
        break;
      case esp32ir::Protocol::Samsung:
        payloadDecoded = esp32ir::decodeSamsung(result, samsung);
        break;
      case esp32ir::Protocol::LG:
        payloadDecoded = esp32ir::decodeLG(result, lg);
        break;
      case esp32ir::Protocol::Denon:
        payloadDecoded = esp32ir::decodeDenon(result, denon);
        break;
      case esp32ir::Protocol::RC5:
        payloadDecoded = esp32ir::decodeRC5(result, rc5);
        break;
      case esp32ir::Protocol::RC6:
        payloadDecoded = esp32ir::decodeRC6(result, rc6);
        break;
      case esp32ir::Protocol::Apple:
        payloadDecoded = esp32ir::decodeApple(result, apple);
        break;
      case esp32ir::Protocol::Pioneer:
        payloadDecoded = esp32ir::decodePioneer(result, pioneer);
        break;
      case esp32ir::Protocol::Toshiba:
        payloadDecoded = esp32ir::decodeToshiba(result, toshiba);
        break;
      case esp32ir::Protocol::Mitsubishi:
        payloadDecoded = esp32ir::decodeMitsubishi(result, mitsu);
        break;
      case esp32ir::Protocol::Hitachi:
        payloadDecoded = esp32ir::decodeHitachi(result, hitachi);
        break;
      default:
        break;
      }
    }

    // en: output decode summary
    // ja: デコード結果サマリを出力
    Serial.printf("status=%s protocol=%s rawFrames=%u\n",
                  (result.status == esp32ir::RxStatus::DECODED    ? "DECODED"
                   : result.status == esp32ir::RxStatus::RAW_ONLY ? "RAW_ONLY"
                   : result.status == esp32ir::RxStatus::OVERFLOW ? "OVERFLOW"
                                                                  : "UNKNOWN"),
                  esp32ir::util::protocolToString(result.protocol),
                  result.raw.frameCount());
    if (!result.payloadStorage.empty())
    {
      std::string fb = bytesToString(result.payloadStorage);
      Serial.printf("frameBytes=[%s]\n", fb.c_str());
    }
    if (payloadDecoded)
    {
      switch (result.protocol)
      {
      case esp32ir::Protocol::NEC:
        Serial.printf("NEC payload: addr=0x%04X(%u) cmd=0x%02X(%u) repeat=%s\n",
                      nec.address, nec.address, nec.command, nec.command,
                      nec.repeat ? "true" : "false");
        break;
      case esp32ir::Protocol::SONY:
        Serial.printf("SONY payload: addr=0x%04X(%u) cmd=0x%04X(%u) bits=%u\n",
                      sony.address, sony.address, sony.command, sony.command, sony.bits);
        break;
      case esp32ir::Protocol::AEHA:
        Serial.printf("AEHA payload: addr=0x%04X(%u) data=0x%08lX bits=%u\n",
                      aeha.address, aeha.address, static_cast<unsigned long>(aeha.data), aeha.nbits);
        break;
      case esp32ir::Protocol::Panasonic:
        Serial.printf("Panasonic payload: addr=0x%04X(%u) data=0x%08lX bits=%u\n",
                      pana.address, pana.address, static_cast<unsigned long>(pana.data), pana.nbits);
        break;
      case esp32ir::Protocol::JVC:
        Serial.printf("JVC payload: addr=0x%04X(%u) cmd=0x%04X(%u)\n",
                      jvc.address, jvc.address, jvc.command, jvc.command);
        break;
      case esp32ir::Protocol::Samsung:
        Serial.printf("Samsung payload: addr=0x%04X(%u) cmd=0x%04X(%u)\n",
                      samsung.address, samsung.address, samsung.command, samsung.command);
        break;
      case esp32ir::Protocol::LG:
        Serial.printf("LG payload: addr=0x%04X(%u) cmd=0x%04X(%u)\n",
                      lg.address, lg.address, lg.command, lg.command);
        break;
      case esp32ir::Protocol::Denon:
        Serial.printf("Denon payload: addr=0x%04X(%u) cmd=0x%04X(%u) repeat=%s\n",
                      denon.address, denon.address, denon.command, denon.command, denon.repeat ? "true" : "false");
        break;
      case esp32ir::Protocol::RC5:
        Serial.printf("RC5 payload: cmd=0x%04X(%u) toggle=%s\n",
                      rc5.command, rc5.command, rc5.toggle ? "true" : "false");
        break;
      case esp32ir::Protocol::RC6:
        Serial.printf("RC6 payload: cmd=0x%08lX(%lu) mode=%u toggle=%s\n",
                      static_cast<unsigned long>(rc6.command), static_cast<unsigned long>(rc6.command),
                      rc6.mode, rc6.toggle ? "true" : "false");
        break;
      case esp32ir::Protocol::Apple:
        Serial.printf("Apple payload: addr=0x%04X(%u) cmd=0x%02X(%u)\n",
                      apple.address, apple.address, apple.command, apple.command);
        break;
      case esp32ir::Protocol::Pioneer:
        Serial.printf("Pioneer payload: addr=0x%04X(%u) cmd=0x%04X(%u) extra=0x%02X(%u)\n",
                      pioneer.address, pioneer.address, pioneer.command, pioneer.command, pioneer.extra, pioneer.extra);
        break;
      case esp32ir::Protocol::Toshiba:
        Serial.printf("Toshiba payload: addr=0x%04X(%u) cmd=0x%04X(%u) extra=0x%02X(%u)\n",
                      toshiba.address, toshiba.address, toshiba.command, toshiba.command, toshiba.extra, toshiba.extra);
        break;
      case esp32ir::Protocol::Mitsubishi:
        Serial.printf("Mitsubishi payload: addr=0x%04X(%u) cmd=0x%04X(%u) extra=0x%02X(%u)\n",
                      mitsu.address, mitsu.address, mitsu.command, mitsu.command, mitsu.extra, mitsu.extra);
        break;
      case esp32ir::Protocol::Hitachi:
        Serial.printf("Hitachi payload: addr=0x%04X(%u) cmd=0x%04X(%u) extra=0x%02X(%u)\n",
                      hitachi.address, hitachi.address, hitachi.command, hitachi.command, hitachi.extra, hitachi.extra);
        break;
      default:
        Serial.println(F("payload: (not decoded in sample)"));
        break;
      }
    }

    bool ok = true;
    cJSON *expected = cJSON_GetObjectItemCaseSensitive(root, "expected");
    if (expected && cJSON_IsObject(expected))
    {
      // en: show expected info for visibility
      // ja: 想定値を事前に表示
      std::string expProto = getStringField(expected, "protocol");
      std::vector<uint8_t> expBytes = parseFrameBytes(expected);
      cJSON *payloadObj = cJSON_GetObjectItemCaseSensitive(expected, "payload");
    const char *actualProtoStr = esp32ir::util::protocolToString(result.protocol);
      cJSON *expPayload = nullptr;
      if (payloadObj && actualProtoStr)
      {
        // if payload is nested under protocol name, pick that; otherwise treat payload object as-is
        cJSON *maybe = cJSON_GetObjectItemCaseSensitive(payloadObj, actualProtoStr);
        expPayload = cJSON_IsObject(maybe) ? maybe : payloadObj;
      }

      if (!expProto.empty() || !expBytes.empty() || expPayload)
      {
        Serial.print(F("expected: "));
        bool first = true;
        if (!expProto.empty())
        {
          Serial.printf("protocol=%s", expProto.c_str());
          first = false;
        }
        if (!expBytes.empty())
        {
          std::string fb = bytesToString(expBytes);
          if (!first)
            Serial.print(F(", "));
          Serial.printf("frameBytes=[%s]", fb.c_str());
          first = false;
        }
        if (expPayload && cJSON_IsObject(expPayload))
        {
          if (!first)
            Serial.print(F(", "));
          Serial.printf("%s payload: ", actualProtoStr);
          auto printNum = [&](const char *key) -> bool
          {
            cJSON *v = cJSON_GetObjectItemCaseSensitive(expPayload, key);
            if (cJSON_IsNumber(v))
            {
              Serial.printf("%s=%d ", key, v->valueint);
              return true;
            }
            return false;
          };
          auto printBool = [&](const char *key) -> bool
          {
            cJSON *v = cJSON_GetObjectItemCaseSensitive(expPayload, key);
            if (cJSON_IsBool(v))
            {
              Serial.printf("%s=%s ", key, cJSON_IsTrue(v) ? "true" : "false");
              return true;
            }
            return false;
          };
          // print known fields in generic way
          printNum("address");
          printNum("command");
          printNum("data");
          printNum("nbits");
          printNum("bits");
          printNum("mode");
          printNum("extra");
          printBool("repeat");
          printBool("toggle");
        }
        Serial.println();
      }

      if (!expProto.empty() && expProto != actualProtoStr)
      {
        ok = false;
        Serial.println(F("FAIL: protocol mismatch"));
      }
      // frameBytes check
      if (!expBytes.empty())
      {
        if (expBytes.size() != result.payloadStorage.size() ||
            !std::equal(expBytes.begin(), expBytes.end(), result.payloadStorage.begin()))
        {
          ok = false;
          Serial.println(F("FAIL: frameBytes mismatch"));
        }
      }
      // payload check (protocol-specific, if expected is provided)
      if (payloadObj && cJSON_IsObject(payloadObj))
      {
        auto getNum = [](cJSON *o, const char *k, int &out) -> bool
        {
          cJSON *v = cJSON_GetObjectItemCaseSensitive(o, k);
          if (cJSON_IsNumber(v))
          {
            out = v->valueint;
            return true;
          }
          return false;
        };
        auto getBool = [](cJSON *o, const char *k, bool &out) -> bool
        {
          cJSON *v = cJSON_GetObjectItemCaseSensitive(o, k);
          if (cJSON_IsBool(v))
          {
            out = cJSON_IsTrue(v);
            return true;
          }
          return false;
        };

        if (expPayload && cJSON_IsObject(expPayload))
        {
          if (!payloadDecoded)
          {
            ok = false;
            Serial.println(F("FAIL: payload expected but decode failed"));
          }
          else
          {
            switch (result.protocol)
            {
            case esp32ir::Protocol::NEC:
            {
              int a = 0, c = 0;
              bool r = false, ha = getNum(expPayload, "address", a), hc = getNum(expPayload, "command", c), hr = getBool(expPayload, "repeat", r);
              if ((ha && nec.address != a) || (hc && nec.command != c) || (hr && nec.repeat != r))
              {
                ok = false;
                Serial.println(F("FAIL: NEC payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::SONY:
            {
              int a = 0, c = 0, b = 0;
              bool ha = getNum(expPayload, "address", a), hc = getNum(expPayload, "command", c), hb = getNum(expPayload, "bits", b);
              if ((ha && sony.address != a) || (hc && sony.command != c) || (hb && sony.bits != b))
              {
                ok = false;
                Serial.println(F("FAIL: SONY payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::AEHA:
            {
              int a = 0, d = 0, b = 0;
              bool ha = getNum(expPayload, "address", a), hd = getNum(expPayload, "data", d), hb = getNum(expPayload, "nbits", b);
              if ((ha && aeha.address != a) || (hd && static_cast<int>(aeha.data) != d) || (hb && aeha.nbits != b))
              {
                ok = false;
                Serial.println(F("FAIL: AEHA payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::Panasonic:
            {
              int a = 0, d = 0, b = 0;
              bool ha = getNum(expPayload, "address", a), hd = getNum(expPayload, "data", d), hb = getNum(expPayload, "nbits", b);
              if ((ha && pana.address != a) || (hd && static_cast<int>(pana.data) != d) || (hb && pana.nbits != b))
              {
                ok = false;
                Serial.println(F("FAIL: Panasonic payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::JVC:
            {
              int a = 0, c = 0;
              bool ha = getNum(expPayload, "address", a), hc = getNum(expPayload, "command", c);
              if ((ha && jvc.address != a) || (hc && jvc.command != c))
              {
                ok = false;
                Serial.println(F("FAIL: JVC payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::Samsung:
            {
              int a = 0, c = 0;
              bool ha = getNum(expPayload, "address", a), hc = getNum(expPayload, "command", c);
              if ((ha && samsung.address != a) || (hc && samsung.command != c))
              {
                ok = false;
                Serial.println(F("FAIL: Samsung payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::LG:
            {
              int a = 0, c = 0;
              bool ha = getNum(expPayload, "address", a), hc = getNum(expPayload, "command", c);
              if ((ha && lg.address != a) || (hc && lg.command != c))
              {
                ok = false;
                Serial.println(F("FAIL: LG payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::Denon:
            {
              int a = 0, c = 0;
              bool r = false, ha = getNum(expPayload, "address", a), hc = getNum(expPayload, "command", c), hr = getBool(expPayload, "repeat", r);
              if ((ha && denon.address != a) || (hc && denon.command != c) || (hr && denon.repeat != r))
              {
                ok = false;
                Serial.println(F("FAIL: Denon payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::RC5:
            {
              int c = 0;
              bool t = false, hc = getNum(expPayload, "command", c), ht = getBool(expPayload, "toggle", t);
              if ((hc && rc5.command != c) || (ht && rc5.toggle != t))
              {
                ok = false;
                Serial.println(F("FAIL: RC5 payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::RC6:
            {
              int c = 0, m = 0;
              bool t = false, hc = getNum(expPayload, "command", c), hm = getNum(expPayload, "mode", m), ht = getBool(expPayload, "toggle", t);
              if ((hc && static_cast<int>(rc6.command) != c) || (hm && rc6.mode != m) || (ht && rc6.toggle != t))
              {
                ok = false;
                Serial.println(F("FAIL: RC6 payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::Apple:
            {
              int a = 0, c = 0;
              bool ha = getNum(expPayload, "address", a), hc = getNum(expPayload, "command", c);
              if ((ha && apple.address != a) || (hc && apple.command != c))
              {
                ok = false;
                Serial.println(F("FAIL: Apple payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::Pioneer:
            {
              int a = 0, c = 0, e = 0;
              bool ha = getNum(expPayload, "address", a), hc = getNum(expPayload, "command", c), he = getNum(expPayload, "extra", e);
              if ((ha && pioneer.address != a) || (hc && pioneer.command != c) || (he && pioneer.extra != e))
              {
                ok = false;
                Serial.println(F("FAIL: Pioneer payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::Toshiba:
            {
              int a = 0, c = 0, e = 0;
              bool ha = getNum(expPayload, "address", a), hc = getNum(expPayload, "command", c), he = getNum(expPayload, "extra", e);
              if ((ha && toshiba.address != a) || (hc && toshiba.command != c) || (he && toshiba.extra != e))
              {
                ok = false;
                Serial.println(F("FAIL: Toshiba payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::Mitsubishi:
            {
              int a = 0, c = 0, e = 0;
              bool ha = getNum(expPayload, "address", a), hc = getNum(expPayload, "command", c), he = getNum(expPayload, "extra", e);
              if ((ha && mitsu.address != a) || (hc && mitsu.command != c) || (he && mitsu.extra != e))
              {
                ok = false;
                Serial.println(F("FAIL: Mitsubishi payload mismatch"));
              }
              break;
            }
            case esp32ir::Protocol::Hitachi:
            {
              int a = 0, c = 0, e = 0;
              bool ha = getNum(expPayload, "address", a), hc = getNum(expPayload, "command", c), he = getNum(expPayload, "extra", e);
              if ((ha && hitachi.address != a) || (hc && hitachi.command != c) || (he && hitachi.extra != e))
              {
                ok = false;
                Serial.println(F("FAIL: Hitachi payload mismatch"));
              }
              break;
            }
            default:
              // AC and others not decoded here yet
              break;
            }
          }
        }
      }
    }

    Serial.print(F("raw frames: "));
    Serial.println(result.raw.frameCount());
    Serial.print(F("decoded: "));
    Serial.println(result.status == esp32ir::RxStatus::DECODED ? "true" : "false");
    Serial.print(F("result: "));
    Serial.println(ok ? "PASS" : "FAIL");
    Serial.println();

    total++;
    if (ok)
      passed++;
    cJSON_Delete(root);
  }

  Serial.print(F("# summary: "));
  Serial.print(passed);
  Serial.print(F(" / "));
  Serial.print(total);
  Serial.println(F(" passed"));
}

void loop() {}
