// en: Replay embedded capture assets and try to decode them.
// ja: 埋め込みキャプチャ資産を読み込み、デコードして表示するサンプル。
// en: Assets are embedded as C arrays via assets_embed.h (generated by the CLI).
// ja: アセットはCLIで生成された assets_embed.h 内の配列として埋め込まれている。

#include <ESP32IRPulseCodec.h>
#include "assets_embed.h"
#include <vector>
#include <string>
#include <array>
#include <cstring>
#include <cstdio>
#include <cJSON.h>

// en: Map protocol string to enum (minimal set; extend as needed)
// ja: プロトコル名文字列をenumに変換（必要に応じて拡張）
static esp32ir::Protocol toProtocol(const std::string &s)
{
  if (s == "NEC") return esp32ir::Protocol::NEC;
  if (s == "SONY") return esp32ir::Protocol::SONY;
  if (s == "AEHA") return esp32ir::Protocol::AEHA;
  if (s == "Panasonic") return esp32ir::Protocol::Panasonic;
  if (s == "JVC") return esp32ir::Protocol::JVC;
  if (s == "Samsung") return esp32ir::Protocol::Samsung;
  if (s == "LG") return esp32ir::Protocol::LG;
  if (s == "Denon") return esp32ir::Protocol::Denon;
  if (s == "RC5") return esp32ir::Protocol::RC5;
  if (s == "RC6") return esp32ir::Protocol::RC6;
  if (s == "Apple") return esp32ir::Protocol::Apple;
  if (s == "Pioneer") return esp32ir::Protocol::Pioneer;
  if (s == "Toshiba") return esp32ir::Protocol::Toshiba;
  if (s == "Mitsubishi") return esp32ir::Protocol::Mitsubishi;
  if (s == "Hitachi") return esp32ir::Protocol::Hitachi;
  if (s == "DaikinAC") return esp32ir::Protocol::DaikinAC;
  if (s == "PanasonicAC") return esp32ir::Protocol::PanasonicAC;
  if (s == "MitsubishiAC") return esp32ir::Protocol::MitsubishiAC;
  if (s == "ToshibaAC") return esp32ir::Protocol::ToshibaAC;
  if (s == "FujitsuAC") return esp32ir::Protocol::FujitsuAC;
  return esp32ir::Protocol::RAW;
}

// en: read embedded asset into RAM buffer (ESP32 stores in regular addressable memory)
// ja: 埋め込みアセットをRAMに読み込む（ESP32では通常メモリとして扱える）
static bool loadAssetToBuffer(size_t idx, std::vector<char> &out)
{
  if (idx >= assets_file_count) return false;
  size_t len = assets_file_sizes[idx];
  out.resize(len + 1);
  memcpy(out.data(), assets_file_data[idx], len);
  out[len] = '\0';
  return true;
}

// en: get string field from JSON (cJSON)
// ja: cJSON から文字列フィールドを取得
static std::string getStringField(cJSON *obj, const char *key)
{
  cJSON *item = cJSON_GetObjectItemCaseSensitive(obj, key);
  if (cJSON_IsString(item) && item->valuestring) return std::string(item->valuestring);
  return {};
}

// en: parse frameBytes array (decimal) if present
// ja: frameBytes 配列（10進）をパース
static std::vector<uint8_t> parseFrameBytes(cJSON *capture)
{
  std::vector<uint8_t> bytes;
  cJSON *arr = cJSON_GetObjectItemCaseSensitive(capture, "frameBytes");
  if (!cJSON_IsArray(arr)) return bytes;
  cJSON *it = nullptr;
  cJSON_ArrayForEach(it, arr)
  {
    if (cJSON_IsNumber(it))
    {
      int v = it->valueint;
      if (v < 0) v = 0;
      if (v > 255) v = 255;
      bytes.push_back(static_cast<uint8_t>(v));
    }
  }
  return bytes;
}

// en: convert bytes to comma separated decimal string (for logging)
// ja: バイト列を10進のカンマ区切り文字列に変換（ログ出力用）
static std::string bytesToString(const std::vector<uint8_t> &bytes)
{
  std::string s;
  s.reserve(bytes.size() * 4);
  for (size_t i = 0; i < bytes.size(); ++i)
  {
    char buf[6];
    snprintf(buf, sizeof(buf), "%u", bytes[i]);
    if (i) s += ",";
    s += buf;
  }
  return s;
}

// en: try decoding NEC from frameBytes by reusing decodeNEC (message path)
// ja: frameBytes を message として渡し decodeNEC を使ってデコードする
static bool decodeNECFromFrameBytes(const std::vector<uint8_t> &bytes, esp32ir::payload::NEC &out)
{
  if (bytes.size() < 4) return false;
  esp32ir::payload::NEC payload{};
  payload.address = static_cast<uint16_t>(bytes[0] | (static_cast<uint16_t>(bytes[1]) << 8));
  payload.command = bytes[2];
  payload.repeat = false; // full frame => not repeat burst
  std::array<uint8_t, sizeof(esp32ir::payload::NEC)> buf{};
  std::memcpy(buf.data(), &payload, sizeof(payload));

  esp32ir::RxResult rx{};
  rx.protocol = esp32ir::Protocol::NEC;
  rx.status = esp32ir::RxStatus::DECODED;
  rx.message = {esp32ir::Protocol::NEC, buf.data(), static_cast<uint16_t>(buf.size()), 0};

  return esp32ir::decodeNEC(rx, out);
}

// en: build ITPSBuffer from JSON by cJSON traversal
// ja: cJSONでitps配列を辿ってITPSBufferを構築
static esp32ir::ITPSBuffer buildITPS(cJSON *capture)
{
  esp32ir::ITPSBuffer buf;
  cJSON *arr = cJSON_GetObjectItemCaseSensitive(capture, "itps");
  if (!cJSON_IsArray(arr)) return buf;
  cJSON *frameObj = nullptr;
  cJSON_ArrayForEach(frameObj, arr)
  {
    if (!cJSON_IsObject(frameObj)) continue;
    cJSON *t = cJSON_GetObjectItemCaseSensitive(frameObj, "T_us");
    uint16_t T_us = t && cJSON_IsNumber(t) ? static_cast<uint16_t>(t->valueint) : 0;
    cJSON *f = cJSON_GetObjectItemCaseSensitive(frameObj, "flags");
    uint8_t flags = f && cJSON_IsNumber(f) ? static_cast<uint8_t>(f->valueint) : 0;

    std::vector<int8_t> seq;
    cJSON *seqArr = cJSON_GetObjectItemCaseSensitive(frameObj, "seq");
    if (cJSON_IsArray(seqArr))
    {
      cJSON *sv = nullptr;
      cJSON_ArrayForEach(sv, seqArr)
      {
        if (cJSON_IsNumber(sv))
        {
          int v = sv->valueint;
          if (v < -128) v = -128;
          if (v > 127) v = 127;
          seq.push_back(static_cast<int8_t>(v));
        }
      }
    }
    esp32ir::ITPSFrame frame{T_us, static_cast<uint16_t>(seq.size()), seq.data(), flags};
    buf.addFrame(frame);
  }
  return buf;
}

void setup()
{
  Serial.begin(115200);
  delay(500);

  Serial.println(F("# assets replay start"));

  size_t total = 0;
  size_t passed = 0;

  for (size_t i = 0; i < assets_file_count; ++i)
  {
    Serial.print(F("## file: "));
    Serial.println(assets_file_names[i]);

    std::vector<char> jsonBuf;
    if (!loadAssetToBuffer(i, jsonBuf))
    {
      Serial.println(F("load failed"));
      continue;
    }

    cJSON *root = cJSON_Parse(jsonBuf.data());
    if (!root)
    {
      Serial.println(F("parse error"));
      continue;
    }

    std::string protoStr = getStringField(root, "protocol");
    if (protoStr.empty()) protoStr = "RAW";
    esp32ir::Protocol proto = toProtocol(protoStr);

    cJSON *capture = cJSON_GetObjectItemCaseSensitive(root, "capture");
    std::vector<uint8_t> frameBytes = capture ? parseFrameBytes(capture) : std::vector<uint8_t>{};

    esp32ir::RxResult rx{};
    rx.status = frameBytes.empty() ? esp32ir::RxStatus::RAW_ONLY : esp32ir::RxStatus::DECODED;
    rx.protocol = proto;
    rx.payloadStorage.assign(frameBytes.begin(), frameBytes.end());
    // en: message points to protocol payload; for assets we keep it null to force decode from raw
    // ja: messageはプロトコルのペイロードを指すので、資産読み込み時はnullにしてrawデコードを優先
    rx.message = {proto, nullptr, 0, 0};
    rx.raw = capture ? buildITPS(capture) : esp32ir::ITPSBuffer{};

    bool decoded = false;
    // decoded payload holders
    esp32ir::payload::NEC nec{};
    esp32ir::payload::SONY sony{};
    esp32ir::payload::AEHA aeha{};
    esp32ir::payload::Panasonic pana{};
    esp32ir::payload::JVC jvc{};
    esp32ir::payload::Samsung samsung{};
    esp32ir::payload::LG lg{};
    esp32ir::payload::Denon denon{};
    esp32ir::payload::RC5 rc5{};
    esp32ir::payload::RC6 rc6{};
    esp32ir::payload::Apple apple{};
    esp32ir::payload::Pioneer pioneer{};
    esp32ir::payload::Toshiba toshiba{};
    esp32ir::payload::Mitsubishi mitsu{};
    esp32ir::payload::Hitachi hitachi{};

    switch (proto)
    {
    case esp32ir::Protocol::NEC:
    {
      decoded = esp32ir::decodeNEC(rx, nec);
      // en: fallback to frameBytes if raw decode fails (use decodeNEC message path)
      // ja: rawデコードに失敗したらframeBytesをmessageとしてdecodeNECを再実行
      if (!decoded && !frameBytes.empty())
      {
        decoded = decodeNECFromFrameBytes(frameBytes, nec);
      }
      if (decoded)
      {
        std::string fb = bytesToString(frameBytes);
        Serial.printf("NEC decoded: addr=0x%04X(%u) cmd=0x%02X(%u) repeat=%s frameBytes=[%s]\n",
                      nec.address, nec.address, nec.command, nec.command,
                      nec.repeat ? "true" : "false", fb.c_str());
      }
      break;
    }
    case esp32ir::Protocol::SONY:
    {
      esp32ir::payload::SONY p{};
      decoded = esp32ir::decodeSONY(rx, p);
      if (decoded)
        Serial.printf("SONY decoded: addr=0x%04X cmd=0x%04X bits=%u\n", p.address, p.command, p.bits);
      sony = p;
      break;
    }
    case esp32ir::Protocol::AEHA:
    {
      esp32ir::payload::AEHA p{};
      decoded = esp32ir::decodeAEHA(rx, p);
      if (decoded)
        Serial.printf("AEHA decoded: addr=0x%04X data=0x%08lX nbits=%u\n", p.address, static_cast<unsigned long>(p.data), p.nbits);
      aeha = p;
      break;
    }
    case esp32ir::Protocol::Panasonic:
    {
      esp32ir::payload::Panasonic p{};
      decoded = esp32ir::decodePanasonic(rx, p);
      if (decoded)
        Serial.printf("Panasonic decoded: addr=0x%04X data=0x%08lX nbits=%u\n", p.address, static_cast<unsigned long>(p.data), p.nbits);
      pana = p;
      break;
    }
    case esp32ir::Protocol::JVC:
    {
      esp32ir::payload::JVC p{};
      decoded = esp32ir::decodeJVC(rx, p);
      if (decoded)
        Serial.printf("JVC decoded: addr=0x%04X cmd=0x%04X\n", p.address, p.command);
      jvc = p;
      break;
    }
    case esp32ir::Protocol::Samsung:
    {
      esp32ir::payload::Samsung p{};
      decoded = esp32ir::decodeSamsung(rx, p);
      if (decoded)
        Serial.printf("Samsung decoded: addr=0x%04X cmd=0x%04X\n", p.address, p.command);
      samsung = p;
      break;
    }
    case esp32ir::Protocol::LG:
    {
      esp32ir::payload::LG p{};
      decoded = esp32ir::decodeLG(rx, p);
      if (decoded)
        Serial.printf("LG decoded: addr=0x%04X cmd=0x%04X\n", p.address, p.command);
      lg = p;
      break;
    }
    case esp32ir::Protocol::Denon:
    {
      esp32ir::payload::Denon p{};
      decoded = esp32ir::decodeDenon(rx, p);
      if (decoded)
        Serial.printf("Denon decoded: addr=0x%04X cmd=0x%04X repeat=%s\n", p.address, p.command, p.repeat ? "true" : "false");
      denon = p;
      break;
    }
    case esp32ir::Protocol::RC5:
    {
      esp32ir::payload::RC5 p{};
      decoded = esp32ir::decodeRC5(rx, p);
      if (decoded)
        Serial.printf("RC5 decoded: cmd=0x%04X toggle=%s\n", p.command, p.toggle ? "true" : "false");
      rc5 = p;
      break;
    }
    case esp32ir::Protocol::RC6:
    {
      esp32ir::payload::RC6 p{};
      decoded = esp32ir::decodeRC6(rx, p);
      if (decoded)
        Serial.printf("RC6 decoded: cmd=0x%08lX mode=%u toggle=%s\n", static_cast<unsigned long>(p.command), p.mode, p.toggle ? "true" : "false");
      rc6 = p;
      break;
    }
    case esp32ir::Protocol::Apple:
    {
      esp32ir::payload::Apple p{};
      decoded = esp32ir::decodeApple(rx, p);
      if (decoded)
        Serial.printf("Apple decoded: addr=0x%04X cmd=0x%02X\n", p.address, p.command);
      apple = p;
      break;
    }
    case esp32ir::Protocol::Pioneer:
    {
      esp32ir::payload::Pioneer p{};
      decoded = esp32ir::decodePioneer(rx, p);
      if (decoded)
        Serial.printf("Pioneer decoded: addr=0x%04X cmd=0x%04X extra=0x%02X\n", p.address, p.command, p.extra);
      pioneer = p;
      break;
    }
    case esp32ir::Protocol::Toshiba:
    {
      esp32ir::payload::Toshiba p{};
      decoded = esp32ir::decodeToshiba(rx, p);
      if (decoded)
        Serial.printf("Toshiba decoded: addr=0x%04X cmd=0x%04X extra=0x%02X\n", p.address, p.command, p.extra);
      toshiba = p;
      break;
    }
    case esp32ir::Protocol::Mitsubishi:
    {
      esp32ir::payload::Mitsubishi p{};
      decoded = esp32ir::decodeMitsubishi(rx, p);
      if (decoded)
        Serial.printf("Mitsubishi decoded: addr=0x%04X cmd=0x%04X extra=0x%02X\n", p.address, p.command, p.extra);
      mitsu = p;
      break;
    }
    case esp32ir::Protocol::Hitachi:
    {
      esp32ir::payload::Hitachi p{};
      decoded = esp32ir::decodeHitachi(rx, p);
      if (decoded)
        Serial.printf("Hitachi decoded: addr=0x%04X cmd=0x%04X extra=0x%02X\n", p.address, p.command, p.extra);
      hitachi = p;
      break;
    }
    default:
      Serial.println(F("decode skipped (protocol not handled in sample)"));
      break;
    }

    bool ok = true;
    cJSON *expected = cJSON_GetObjectItemCaseSensitive(root, "expected");
    if (expected && cJSON_IsObject(expected))
    {
      // en: show expected info for visibility
      // ja: 想定値を事前に表示
      // protocol check
      std::string expProto = getStringField(expected, "protocol");
      std::vector<uint8_t> expBytes = parseFrameBytes(expected);
      cJSON *payloadObj = cJSON_GetObjectItemCaseSensitive(expected, "payload");
      cJSON *necObj = payloadObj ? cJSON_GetObjectItemCaseSensitive(payloadObj, "NEC") : nullptr;

      if (!expProto.empty() || !expBytes.empty() || necObj)
      {
        Serial.print(F("expected: "));
        bool first = true;
        if (!expProto.empty())
        {
          Serial.printf("protocol=%s", expProto.c_str());
          first = false;
        }
        if (!expBytes.empty())
        {
          std::string fb = bytesToString(expBytes);
          if (!first) Serial.print(F(", "));
          Serial.printf("frameBytes=[%s]", fb.c_str());
          first = false;
        }
        if (necObj && cJSON_IsObject(necObj))
        {
          cJSON *a = cJSON_GetObjectItemCaseSensitive(necObj, "address");
          cJSON *c = cJSON_GetObjectItemCaseSensitive(necObj, "command");
          cJSON *r = cJSON_GetObjectItemCaseSensitive(necObj, "repeat");
          if ((!first) && (cJSON_IsNumber(a) || cJSON_IsNumber(c) || cJSON_IsBool(r))) Serial.print(F(", "));
          std::string addrStr = "-";
          std::string cmdStr = "-";
          if (cJSON_IsNumber(a))
          {
            char buf[16];
            snprintf(buf, sizeof(buf), "0x%04X", static_cast<uint16_t>(a->valueint));
            addrStr = std::to_string(a->valueint) + " (" + buf + ")";
          }
          if (cJSON_IsNumber(c))
          {
            char buf[16];
            snprintf(buf, sizeof(buf), "0x%02X", static_cast<uint8_t>(c->valueint));
            cmdStr = std::to_string(c->valueint) + " (" + buf + ")";
          }
          const char *repStr = cJSON_IsBool(r) ? (cJSON_IsTrue(r) ? "true" : "false") : "-";
          Serial.printf("NEC payload: addr=%s cmd=%s repeat=%s",
                        addrStr.c_str(), cmdStr.c_str(), repStr);
        }
        Serial.println();
      }

      if (!expProto.empty() && expProto != protoStr)
      {
        ok = false;
        Serial.println(F("FAIL: protocol mismatch"));
      }
      // frameBytes check
      if (!expBytes.empty())
      {
        if (expBytes.size() != rx.payloadStorage.size() ||
            !std::equal(expBytes.begin(), expBytes.end(), rx.payloadStorage.begin()))
        {
          ok = false;
          Serial.println(F("FAIL: frameBytes mismatch"));
        }
      }
      // payload check (supported: NEC)
      if (payloadObj && cJSON_IsObject(payloadObj))
      {
        if (necObj && cJSON_IsObject(necObj) && proto == esp32ir::Protocol::NEC)
        {
          cJSON *a = cJSON_GetObjectItemCaseSensitive(necObj, "address");
          cJSON *c = cJSON_GetObjectItemCaseSensitive(necObj, "command");
          cJSON *r = cJSON_GetObjectItemCaseSensitive(necObj, "repeat");
          bool hasAddr = cJSON_IsNumber(a);
          bool hasCmd = cJSON_IsNumber(c);
          bool hasRep = cJSON_IsBool(r);
          int expAddr = hasAddr ? a->valueint : 0;
          int expCmd = hasCmd ? c->valueint : 0;
          bool expRepeat = hasRep ? cJSON_IsTrue(r) : false;
          if (!decoded ||
              (hasAddr && nec.address != expAddr) ||
              (hasCmd && nec.command != expCmd) ||
              (hasRep && nec.repeat != expRepeat))
          {
            ok = false;
            Serial.println(F("FAIL: NEC payload mismatch"));
            std::string expAddrStr = hasAddr ? std::to_string(expAddr) : "-";
            std::string expCmdStr = hasCmd ? std::to_string(expCmd) : "-";
            Serial.printf("actual NEC: addr=%u (0x%04X) cmd=%u (0x%02X) repeat=%s\n",
                          nec.address, nec.address, nec.command, nec.command,
                          nec.repeat ? "true" : "false");
            Serial.printf("expect NEC: addr=%s cmd=%s repeat=%s\n",
                          expAddrStr.c_str(),
                          expCmdStr.c_str(),
                          hasRep ? (expRepeat ? "true" : "false") : "-");
          }
        }
      }
    }

    Serial.print(F("raw frames: "));
    Serial.println(rx.raw.frameCount());
    Serial.print(F("decoded: "));
    Serial.println(decoded ? "true" : "false");
    Serial.print(F("result: "));
    Serial.println(ok ? "PASS" : "FAIL");
    Serial.println();

    total++;
    if (ok) passed++;
    cJSON_Delete(root);
  }

  Serial.print(F("# summary: "));
  Serial.print(passed);
  Serial.print(F(" / "));
  Serial.print(total);
  Serial.println(F(" passed"));
}

void loop() {}
