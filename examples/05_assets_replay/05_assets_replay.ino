// en: Replay embedded capture assets and try to decode them.
// ja: 埋め込みキャプチャ資産を読み込み、デコードして表示するサンプル。
// en: Assets are embedded as C arrays via assets_embed.h (generated by the CLI).
// ja: アセットはCLIで生成された assets_embed.h 内の配列として埋め込まれている。

#include <ESP32IRPulseCodec.h>
#include "assets_embed.h"
#include <vector>
#include <string>
#include <cstring>
#include <cstdlib>

// en: Map protocol string to enum (minimal set; extend as needed)
// ja: プロトコル名文字列をenumに変換（必要に応じて拡張）
static esp32ir::Protocol toProtocol(const std::string &s)
{
  if (s == "NEC")
    return esp32ir::Protocol::NEC;
  if (s == "SONY")
    return esp32ir::Protocol::SONY;
  if (s == "AEHA")
    return esp32ir::Protocol::AEHA;
  if (s == "Panasonic")
    return esp32ir::Protocol::Panasonic;
  if (s == "JVC")
    return esp32ir::Protocol::JVC;
  if (s == "Samsung")
    return esp32ir::Protocol::Samsung;
  if (s == "LG")
    return esp32ir::Protocol::LG;
  if (s == "Denon")
    return esp32ir::Protocol::Denon;
  if (s == "RC5")
    return esp32ir::Protocol::RC5;
  if (s == "RC6")
    return esp32ir::Protocol::RC6;
  if (s == "Apple")
    return esp32ir::Protocol::Apple;
  if (s == "Pioneer")
    return esp32ir::Protocol::Pioneer;
  if (s == "Toshiba")
    return esp32ir::Protocol::Toshiba;
  if (s == "Mitsubishi")
    return esp32ir::Protocol::Mitsubishi;
  if (s == "Hitachi")
    return esp32ir::Protocol::Hitachi;
  if (s == "DaikinAC")
    return esp32ir::Protocol::DaikinAC;
  if (s == "PanasonicAC")
    return esp32ir::Protocol::PanasonicAC;
  if (s == "MitsubishiAC")
    return esp32ir::Protocol::MitsubishiAC;
  if (s == "ToshibaAC")
    return esp32ir::Protocol::ToshibaAC;
  if (s == "FujitsuAC")
    return esp32ir::Protocol::FujitsuAC;
  return esp32ir::Protocol::RAW;
}

// en: read embedded asset into RAM buffer (ESP32 stores in regular addressable memory)
// ja: 埋め込みアセットをRAMに読み込む（ESP32では通常メモリとして扱える）
static bool loadAssetToBuffer(size_t idx, std::vector<char> &out)
{
  if (idx >= assets_file_count)
    return false;
  size_t len = assets_file_sizes[idx];
  out.resize(len + 1);
  memcpy(out.data(), assets_file_data[idx], len);
  out[len] = '\0';
  return true;
}

// en: parse next integer list from a substring "[...]" (signed), append to vector
// ja: "[...]" の整数配列をパースしてベクタに追加
static void parseIntArray(const char *start, std::vector<int> &out)
{
  const char *p = strchr(start, '[');
  if (!p)
    return;
  ++p;
  while (*p && *p != ']')
  {
    char *end = nullptr;
    long v = strtol(p, &end, 10);
    if (p == end)
      break;
    out.push_back(static_cast<int>(v));
    p = end;
    while (*p && *p != ']' && (*p == ' ' || *p == ',' || *p == '\n' || *p == '\r' || *p == '\t'))
      ++p;
  }
}

// en: parse frameBytes array (decimal) if present
// ja: frameBytes 配列（10進）をパース
static std::vector<uint8_t> parseFrameBytes(const char *json)
{
  std::vector<uint8_t> bytes;
  const char *p = strstr(json, "\"frameBytes\"");
  if (!p)
    return bytes;
  std::vector<int> tmp;
  parseIntArray(p, tmp);
  bytes.reserve(tmp.size());
  for (int v : tmp)
  {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    bytes.push_back(static_cast<uint8_t>(v));
  }
  return bytes;
}

// en: naive JSON field extraction for protocol string
// ja: プロトコル名を素朴に抽出
static std::string extractStringField(const char *json, const char *key)
{
  std::string pat = std::string("\"") + key + "\"";
  const char *p = strstr(json, pat.c_str());
  if (!p)
    return {};
  p = strchr(p + pat.size(), '"');
  if (!p)
    return {};
  ++p;
  const char *q = strchr(p, '"');
  if (!q)
    return {};
  return std::string(p, q);
}

// en: build ITPSBuffer from JSON by simple pattern matching
// ja: 簡易パースでJSONからITPSBufferを構築
static esp32ir::ITPSBuffer buildITPS(const char *json)
{
  esp32ir::ITPSBuffer buf;
  const char *itpsPos = strstr(json, "\"itps\"");
  if (!itpsPos)
    return buf;
  const char *p = strchr(itpsPos, '[');
  if (!p)
    return buf;
  while (p && *p)
  {
    p = strchr(p, '{');
    if (!p)
      break;
    const char *frameEnd = strchr(p, '}');
    if (!frameEnd)
      break;

    // slice for this frame
    std::string frameStr(p, frameEnd + 1);

    // T_us
    uint16_t T_us = 0;
    {
      const char *t = strstr(frameStr.c_str(), "\"T_us\"");
      if (t)
      {
        t = strchr(t, ':');
        if (t)
          T_us = static_cast<uint16_t>(atoi(t + 1));
      }
    }

    // flags
    uint8_t flags = 0;
    {
      const char *t = strstr(frameStr.c_str(), "\"flags\"");
      if (t)
      {
        t = strchr(t, ':');
        if (t)
          flags = static_cast<uint8_t>(atoi(t + 1));
      }
    }

    // seq
    std::vector<int> seqInt;
    {
      const char *t = strstr(frameStr.c_str(), "\"seq\"");
      if (t)
        parseIntArray(t, seqInt);
    }
    std::vector<int8_t> seq;
    seq.reserve(seqInt.size());
    for (int v : seqInt)
      seq.push_back(static_cast<int8_t>(v));

    esp32ir::ITPSFrame frame{T_us, static_cast<uint16_t>(seq.size()), seq.data(), flags};
    buf.addFrame(frame);

    p = frameEnd + 1;
    // move to next frame or end of array
    p = strchr(p, '{');
    if (p && p[-1] == ']')
      break;
  }
  return buf;
}

void setup()
{
  Serial.begin(115200);
  delay(1000);

  Serial.println(F("# assets replay start"));

  for (size_t i = 0; i < assets_file_count; ++i)
  {
    Serial.print(F("## file: "));
    Serial.println(assets_file_names[i]);

    std::vector<char> jsonBuf;
    if (!loadAssetToBuffer(i, jsonBuf))
    {
      Serial.println(F("load failed"));
      continue;
    }

    // en: naive parsing (protocol + itps only)
    // ja: プロトコルとitpsだけを簡易パース
    std::string protoStr = extractStringField(jsonBuf.data(), "protocol"); // en: default RAW if missing / ja: 無ければRAW扱い
    if (protoStr.empty())
      protoStr = "RAW";
    esp32ir::Protocol proto = toProtocol(protoStr);

    // frameBytes (optional decoded payload)
    std::vector<uint8_t> frameBytes = parseFrameBytes(jsonBuf.data());

    esp32ir::RxResult rx{}; // en: synthetic RxResult from asset / ja: アセットから擬似RxResultを生成
    rx.status = frameBytes.empty() ? esp32ir::RxStatus::RAW_ONLY : esp32ir::RxStatus::DECODED;
    rx.protocol = proto;
    rx.payloadStorage.assign(frameBytes.begin(), frameBytes.end());
    rx.message = {proto,
                  rx.payloadStorage.empty() ? nullptr : rx.payloadStorage.data(),
                  static_cast<uint16_t>(rx.payloadStorage.size()),
                  0};
    rx.raw = buildITPS(jsonBuf.data());

    bool decoded = false;
    switch (proto)
    {
    case esp32ir::Protocol::NEC:
    {
      esp32ir::payload::NEC nec{};
      decoded = esp32ir::decodeNEC(rx, nec);
      if (decoded)
        Serial.printf("NEC decoded: addr=0x%04X cmd=0x%02X repeat=%s\n", nec.address, nec.command, nec.repeat ? "true" : "false");
      break;
    }
    case esp32ir::Protocol::SONY:
    {
      esp32ir::payload::SONY sony{};
      decoded = esp32ir::decodeSONY(rx, sony);
      if (decoded)
        Serial.printf("SONY decoded: addr=0x%04X cmd=0x%04X bits=%u\n", sony.address, sony.command, sony.bits);
      break;
    }
    case esp32ir::Protocol::AEHA:
    {
      esp32ir::payload::AEHA aeha{};
      decoded = esp32ir::decodeAEHA(rx, aeha);
      if (decoded)
        Serial.printf("AEHA decoded: addr=0x%04X data=0x%08lX nbits=%u\n", aeha.address, static_cast<unsigned long>(aeha.data), aeha.nbits);
      break;
    }
    case esp32ir::Protocol::Panasonic:
    {
      esp32ir::payload::Panasonic p{};
      decoded = esp32ir::decodePanasonic(rx, p);
      if (decoded)
        Serial.printf("Panasonic decoded: addr=0x%04X data=0x%08lX nbits=%u\n", p.address, static_cast<unsigned long>(p.data), p.nbits);
      break;
    }
    case esp32ir::Protocol::JVC:
    {
      esp32ir::payload::JVC p{};
      decoded = esp32ir::decodeJVC(rx, p);
      if (decoded)
        Serial.printf("JVC decoded: addr=0x%04X cmd=0x%04X\n", p.address, p.command);
      break;
    }
    case esp32ir::Protocol::Samsung:
    {
      esp32ir::payload::Samsung p{};
      decoded = esp32ir::decodeSamsung(rx, p);
      if (decoded)
        Serial.printf("Samsung decoded: addr=0x%04X cmd=0x%04X\n", p.address, p.command);
      break;
    }
    case esp32ir::Protocol::LG:
    {
      esp32ir::payload::LG p{};
      decoded = esp32ir::decodeLG(rx, p);
      if (decoded)
        Serial.printf("LG decoded: addr=0x%04X cmd=0x%04X\n", p.address, p.command);
      break;
    }
    case esp32ir::Protocol::Denon:
    {
      esp32ir::payload::Denon p{};
      decoded = esp32ir::decodeDenon(rx, p);
      if (decoded)
        Serial.printf("Denon decoded: addr=0x%04X cmd=0x%04X repeat=%s\n", p.address, p.command, p.repeat ? "true" : "false");
      break;
    }
    case esp32ir::Protocol::RC5:
    {
      esp32ir::payload::RC5 p{};
      decoded = esp32ir::decodeRC5(rx, p);
      if (decoded)
        Serial.printf("RC5 decoded: cmd=0x%04X toggle=%s\n", p.command, p.toggle ? "true" : "false");
      break;
    }
    case esp32ir::Protocol::RC6:
    {
      esp32ir::payload::RC6 p{};
      decoded = esp32ir::decodeRC6(rx, p);
      if (decoded)
        Serial.printf("RC6 decoded: cmd=0x%08lX mode=%u toggle=%s\n", static_cast<unsigned long>(p.command), p.mode, p.toggle ? "true" : "false");
      break;
    }
    case esp32ir::Protocol::Apple:
    {
      esp32ir::payload::Apple p{};
      decoded = esp32ir::decodeApple(rx, p);
      if (decoded)
        Serial.printf("Apple decoded: addr=0x%04X cmd=0x%02X\n", p.address, p.command);
      break;
    }
    case esp32ir::Protocol::Pioneer:
    {
      esp32ir::payload::Pioneer p{};
      decoded = esp32ir::decodePioneer(rx, p);
      if (decoded)
        Serial.printf("Pioneer decoded: addr=0x%04X cmd=0x%04X extra=0x%02X\n", p.address, p.command, p.extra);
      break;
    }
    case esp32ir::Protocol::Toshiba:
    {
      esp32ir::payload::Toshiba p{};
      decoded = esp32ir::decodeToshiba(rx, p);
      if (decoded)
        Serial.printf("Toshiba decoded: addr=0x%04X cmd=0x%04X extra=0x%02X\n", p.address, p.command, p.extra);
      break;
    }
    case esp32ir::Protocol::Mitsubishi:
    {
      esp32ir::payload::Mitsubishi p{};
      decoded = esp32ir::decodeMitsubishi(rx, p);
      if (decoded)
        Serial.printf("Mitsubishi decoded: addr=0x%04X cmd=0x%04X extra=0x%02X\n", p.address, p.command, p.extra);
      break;
    }
    case esp32ir::Protocol::Hitachi:
    {
      esp32ir::payload::Hitachi p{};
      decoded = esp32ir::decodeHitachi(rx, p);
      if (decoded)
        Serial.printf("Hitachi decoded: addr=0x%04X cmd=0x%04X extra=0x%02X\n", p.address, p.command, p.extra);
      break;
    }
    default:
      Serial.println(F("decode skipped (protocol not handled in sample)"));
      break;
    }

    Serial.print(F("raw frames: "));
    Serial.println(rx.raw.frameCount());
    Serial.print(F("decoded: "));
    Serial.println(decoded ? "true" : "false");
    Serial.println();
  }
}

void loop() {}
